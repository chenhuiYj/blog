JavaScript 作为浏览器脚本语言，主要用途是与用户互动，以及操作 DOM。这决定了 JavaScript 只能是单线程，也就是说，同一个时间只能做一件事。否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript 就是单线程。

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript 语言的设计者意识到这个问题，将所有任务分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。

同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；

异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

接下来我们通过两个例子说明同步任务和异步任务的区别：
```javascript
console.log(1)
setTimeout(()=>{
   console.log(3)
},0)
console.log(2)

//结果会输出1，2，3
```

题目中的 setTimeout()就是个异步任务。在所有同步任务执行完之前，任何的异步任务是不会执行的。

异步执行的运行机制如下：

1.所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

2.主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

3.一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
主线程不断重复上面的第三步。

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。只要主线程空了，就会去读取"任务队列"，这就是 JavaScript 的运行机制。这个过程会循环反复。以下这张图可以很好说明这点。

![](https://t12.baidu.com/it/app=25&f=JPEG&fm=173&fmt=auto&u=3568080110%2C3758711556?w=639&h=354&s=5A203C6292FE6588147FCCC40200E0B3)
图片截自：https://baijiahao.baidu.com/s?id=1615713540466951098

javascript 代码运行分两个阶段：
1、预解析---把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前
2、执行---从上到下执行（按照 js 运行机制）
至于放入异步任务队列的时机，我们通过 setTimeout 的例子和 Ajax 例子来详细说明：
```javascript
for(var i=0;i<5;i++){
    setTimeout(()=>{
        console.log(i)
    },1000)
}
```
for 循环一次碰到一个 setTimeout()，并不是马上把 setTimeout()拿到异步队列中，而要等到一秒后，才将其放到任务队列里面，一旦"执行栈"中的所有同步任务执行完毕（即 for 循环结束，此时 i 已经为5），系统就会读取已经存放"任务队列"的 setTimeout()（有五个），于是答案是输出5个5。

上面也提到，在到达指定时间时，定时器就会将相应回调函数插入“任务队列”尾部。这就是“定时器（timer）”功能。

关于定时器的重要补充：

定时器包括 setTimeout 与 setInterval 两个方法。它们的第二个参数是指定其回调函数推迟/间隔多少毫秒数后执行。

对于第二个参数有以下需要注意的地方：当第二个参数缺省时，默认为 0；当指定的值小于 4 毫秒，则增加到 4ms(4ms 是 HTML5 标准指定的，对于 2010 年及之前的浏览器则是 10ms);也就是说至少需要4毫秒，该 setTimeout()拿到任务队列中。

![](https://t11.baidu.com/it/app=25&f=JPEG&fm=173&fmt=auto&u=4048225711%2C640979955?w=640&h=273&s=05926C324B2347244A7504DA000080B2)
图片截自：https://baijiahao.baidu.com/s?id=1615713540466951098

![](https://t12.baidu.com/it/app=25&f=JPEG&fm=173&fmt=auto&u=2413437494%2C67589961?w=640&h=416&s=E6B0C56A52B4937C46E9951D000050C2)
图片截自：https://baijiahao.baidu.com/s?id=1615713540466951098

ajax 加载完成时才会放入异步队列，至于这段时间不确定，所有有两种情况：①大于100ms,最后的结果是 d c b a ;②小于100ms,最后的结果便是 d c a b。

异步任务中的微任务和宏任务。

对于异步任务队列，其实是有更细的分类。其被分为 微任务（microtask）队列 & 宏任务（macrotask）队列。而微任务比宏任务优先执行。

常见微任务：promise，mutation，observer 等。
常见宏任务：setTimeout, setInterval 等。

总结 event loop 执行顺序就是。

1.首先执行主进程（执行栈）的同步任务

2.进程（执行栈）的同步任务执行完毕之后，检查微任务
队列，将可执行的微任务全部执行

3.取宏任务的第一项执行

4.回到第二步

（微任务每次全执行，宏任务每次只取第一项）

总结起来 js 引擎对程序的执行顺序是：

1.先执行同步任务的程序 

2.在执行异步任务里的微任务 

3.所有微任务都执行完了后就执行异步的宏任务，但这里是一个一个宏任务去执行，不是一下子执行完。
```javascript
let result=true
let promise = new Promise((resolve,reject)=>{
    console.log('同步任务1')
    result?resolve('异步微任务成功'):reject('异步微任务失败')
})
console.log('同步任务2')
setTimeout(()=>{
    console.log('异步宏任务')
})
promise.then(res=>{
    console.log(res)
})
console.log('同步任务3')

//同步任务1
//同步任务2
//同步任务3
//异步微任务成功
//异步宏任务
```